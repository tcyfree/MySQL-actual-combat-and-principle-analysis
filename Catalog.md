# 目录大纲

# 第1章 什么影响了数据库查询速度
## 1.1 影响数据库查询速度的四个因素
## 1.2 风险分析
## 1.3 网卡流量：如何避免无法连接数据库的情况
## 1.4 大表带来的问题
### 1.4.1 大表的特点
### 1.4.2 大表的危害
### 1.4.3 如何处理数据库上的大表
## 1.5 大事务带来的问题
### 1.5.1 什么是事务
### 1.5.2 事务的ACID属性
### 1.5.3 大事务

[**什么影响了数据库查询速度**](https://segmentfault.com/a/1190000013672421#articleHeader0)

# 第2章 什么影响了MySQL性能
## 2.1 影响性能的几个方面
## 2.2 MySQL体系结构
## 2.3 InnoDB存储引擎
## 2.3.1 InnoDB使用表空间进行数据存储
### 2.3.2 系统表空间与独立表空间
### 2.3.3 系统表空间的表转移到独立表空间中的方法
## 2.4 InnoDB存储引擎的特性
### 2.4.1 特性一：事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log
### 2.4.2 特性二：支持行级锁
## 2.5 什么是锁
### 2.5.1 锁
### 2.5.2 锁类型
### 2.5.3 锁的粒度
### 2.5.4 阻塞和死锁
## 2.6 如何选择正确的存储引擎
## 2.7 配置参数
### 2.7.1 内存配置相关参数
## 2.8 性能优化顺序

[**什么影响了MySQL性能**](https://segmentfault.com/a/1190000013672421#articleHeader12)

# 第3章 MySQL中字段类型与合理的选择字段类型

## 3.1 字段类型
### 3.1.1 数值
### 3.1.2 字符串类型
### 3.1.3 时间类型

## 3.2 举例
### 3.2.1 int(11)最大长度是多少？
### 3.2.2 varchar最大长度是多少？

## 3.3 总结：合理的选择数据类型

[**MySQL中字段类型与合理的选择字段类型**](https://segmentfault.com/a/1190000010012140)

# 第4章 数据库结构优化
## 4.1 数据库结构优化目的
## 4.2 数据库结构设计步骤
## 4.3 数据库范式设计与反范式化
### 4.3.1 第一范式
### 4.3.2 第二范式
### 4.3.3 第三范式
### 4.3.4 反范式化
### 4.3.5 范式化设计和反范式化设计的优缺点

[**数据库逻辑设计之三大范式通俗理解**](https://segmentfault.com/a/1190000013695030)

## 4.4 物理设计

[**数据库结构优化**](https://segmentfault.com/a/1190000013746118#articleHeader1)

# 第5章 数据库索引优化
## 5.1 数据结构及算法基础
### 5.1.1 索引的本质
### 5.1.2 B-Tree和B+Tree
### 5.1.3 为什么实用B-Tree（B+Tree）
## 5.2 MySQL索引实现
### 5.2.1 MyISAM索引实现         
### 5.2.2 InnoDB索引实现
## 5.3 两种主要数据结构：B-tree和Hash
### 5.3.1 B-tree结构
### 5.3.2 Hash结构
### 5.3.3 MySQL常见索引和各种索引区别
## 5.4 使用索引好处和索引缺陷
### 5.4.1 为什么要使用索引
### 5.4.2 索引不是越多越好
## 5.5 索引优化策略
### 5.5.1 索引列上不能使用表达式和函数
### 5.5.2 前缀索引和索引列的选择性
### 5.5.3 联合索引策略
### 5.5.4 覆盖索引策略
### 5.5.5 SQL索引优化总结口诀
## 5.6 使用索引来优化查询
### 5.6.1 利用索引排序
## 5.7 索引的维护和优化
### 5.7.1 删除重复索引
### 5.7.2 删除冗余索引
## 5.8 InnoDB的主键选择与插入优化

[**数据库索引优化**](https://segmentfault.com/a/1190000013746118#articleHeader8)

# 六 、SQL查询优化
## 6.1 获取有性能问题SQL的三种方式
### 6.1.2 慢查日志分析工具
### 6.1.3 实时获取有性能问题的SQL
## 6.2 SQL的解析预处理及生成执行计划
### 6.2.1 查询过程描述
### 6.2.2 查询缓存对性能的影响（建议关闭缓存）
### 6.2.3 MySQL依照执行计划和存储引擎进行交互
## 6.3 会造成MySQL生成错误的执行计划的原因
## 6.4 MySQL优化器可优化的SQL类型
## 6.5 查询处理各个阶段所需要的时间
### 6.5.1 profile
### 6.5.2 performance_schema
## 6.6 特定SQL的查询优化
### 6.6.1 大表的数据修改
### 6.6.2 大表的结构修改
### 6.6.3 优化not in 和 <> 查询

[**SQL查询优化**](https://segmentfault.com/a/1190000013781544#articleHeader1)

# 七、分库分表
## 7.1 分库分表的几种方式
### 7.1.1 把一个实例中的多个数据库拆分到不同实例（集群）
### 7.1.2 把一个库中的表分离到不同的数据库中
### 7.1.3 数据库分片

[**分库分表**](https://segmentfault.com/a/1190000013781544#articleHeader18)