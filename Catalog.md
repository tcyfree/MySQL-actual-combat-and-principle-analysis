# 目录大纲

# 第2章 MySQL中字段类型与合理的选择字段类型
[MySQL中字段类型与合理的选择字段类型；int(11)最大长度是多少？varchar最大长度是多少？](https://segmentfault.com/a/1190000010012140?_blank)
## 2.1 字段类型
### 2.1.1 数值
### 2.1.2 字符串类型
### 2.1.3 时间类型

## 2.2 举例
### 2.2.1 int(11)最大长度是多少？
### 2.2.2 varchar最大长度是多少？

## 2.3 总结：合理的选择数据类型

# 一、什么影响了数据库查询速度
## 1.1 影响数据库查询速度的四个因素
## 1.2 风险分析
## 1.3 网卡流量：如何避免无法连接数据库的情况
## 1.4 大表带来的问题（重要）
### 1.4.1 大表的特点：
### 1.4.2 大表的危害：
### 1.4.3 如何处理数据库上的大表
## 1.5 大事务带来的问题（重要）
### 1.5.1 什么是事务
### 1.5.2事务的ACID属性
### 1.5.3 大事务
# 二、什么影响了MySQL性能（非常重要）
## 2.1 影响性能的几个方面
## 2.2 MySQL体系结构
## 2.3 InnoDB存储引擎
## 2.3.1 InnoDB使用表空间进行数据存储。
### 2.3.2 (MySQL5.5默认)系统表空间与(MySQL5.6及以后默认)独立表空间
### 2.3.3 系统表空间的表转移到独立表空间中的方法
## 2.4 InnoDB存储引擎的特性
### 2.4.1 特性一：
### 2.4.2 特性二：
## 2.5 如何选择正确的存储引擎
## 2.6 配置参数
### 2.6.1 内存配置相关参数
## 2.7 性能优化顺序

# 三、数据库结构优化
## 1.1 数据库结构优化目的
## 1.2 数据库结构设计步骤
## 1.3 数据库范式设计与反范式化
## 1.4 物理设计

# 四、数据库索引优化
## 4.1 两种主要数据结构：B-tree和Hash
### 4.1.1 B-tree结构
### 4.1.2 Hash结构
### 4.1.3 MySQL常见索引和各种索引区别
## 4.2 使用索引好处和索引缺陷
### 4.2.1 为什么要使用索引
### 4.2.2 索引不是越多越好
## 4.4 索引优化策略
### 4.3.1 索引列上不能使用表达式和函数
### 4.3.2 前缀索引和索引列的选择性
### 4.3.3 联合索引策略
### 4.3.4 覆盖索引策略
### 4.3.5 SQL索引优化总结口诀
## 4.4 使用索引来优化查询
### 4.4.1 利用索引排序
## 4.5 索引的维护和优化
### 4.5.1 删除重复索引
### 4.5.2 删除冗余索引


## 1.1 数据结构及算法基础

### 1.1.1 索引的本质

### 1.1.2 B-Tree和B+Tree

### 1.1.3 为什么实用B-Tree（B+Tree）

## 1.2 MySQL索引实现

### 1.2.1 MyISAM索引实现         

### 1.2.2 InnoDB索引实现

## 1.3 索引用策略及优化

### 1.3.1 示例数据库

### 1.3.2 最左前缀原理与相关优化

### 1.3.3 索引选择性与前缀索引

### 1.3.4 InnoDB的主键选择与插入优化

# 五 、SQL查询优化
## 5.1 获取有性能问题SQL的三种方式
### 5.1.2 慢查日志分析工具
### 5.1.3 实时获取有性能问题的SQL（推荐）
## 5.2 SQL的解析预处理及生成执行计划（重要）
### 5.2.1 查询过程描述（重点！！！）
### 5.2.2 查询缓存对性能的影响（建议关闭缓存）
### 5.2.3 第二阶段：MySQL依照执行计划和存储引擎进行交互
## 5.3 会造成MySQL生成错误的执行计划的原因
## 5.4 MySQL优化器可优化的SQL类型
## 5.5 查询处理各个阶段所需要的时间
### 5.5.1 使用profile(目前已经不推荐使用了)
### 5.5.2 performance_schema是5.5引入的一个性能分析引擎（5.5版本时期开销比较大）
## 5.6 特定SQL的查询优化
### 5.6.1 大表的数据修改
### 5.6.2 大表的结构修改
### 5.6.3 优化not in 和 <> 查询
# 六、分库分表
## 6.1 分库分表的几种方式
### 6.1.1 把一个实例中的多个数据库拆分到不同实例（集群）
### 6.1.2 把一个库中的表分离到不同的数据库中
### 6.1.3 数据库分片